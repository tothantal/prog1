<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalÃ©kban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para> 
            A következõ program egy magot 100 százalékban dolgoztat meg:
        </para>
        
        <programlisting language = "c"> 
                <![CDATA[ 
            #include <stdio.h>

            int main()
            {
                while(1){};
            }
]]>
        </programlisting>>
            
        <para>
             Ez a program egy egyszerû while ciklus, aminek ha a feltétele teljesül, akkor nem csinál
            semmit. Ebben az esetben a feltétel 1, ami 'igaz' vagy angolul 'true' boolean típusú
            értékkel bír, tehát az adott ciklus egy végtelen ciklus, azaz sosem áll le, kivéve ha arra kényszerítjük a CTRL+C 
            betûkombinációval, hiszen az 'igaz' értéke mindig igaz.
        </para>>
         
        <para>
            A következõ program minden magot 100 százalékban dolgoztat meg:
        </para>
        <programlisting language = "c"> 
                <![CDATA[] 
        // compile: gcc name.c -fopenmp

        #include <stdio.h>

        int main()
        {
            #pragma omp parallel
            while(1){};
        }
]]>
        </programlisting>>
        
        <para>
            Ez az elõzõ program módosítása. Ugyanabból a while ciklusból áll némi változtatással.
            A #pragma feladata, hogy a gép vagy az operációs rendszerre vonatkozó specifikus utasítást
            adjon a compilernek, azaz megmondja hogy a compiler tegyen valamit vagy felülírjon valamilyen
            általánosnak vett utasítást. Itt a #pragma szerepe a felülírás. Normális esetben, mint azt felül is láthattuk,
            ez a program #pragma nélkül csak 1 processzort dolgoztat meg 100 százalékon, de az omp parallel utsítás
            azt mondja a compilernek, hogy egyszerre több szálon fusson a program, azaz több processzor dolgozzon rajta egy idõben, aminek 
            az eredménye, hogy ez a program az összes processzort 100 százalékosan megdolgoztatja.
        </para>
        
        <para>
            A következõ program 0 százalékon dolgoztat meg egy magot:
        </para>
            
            <programlisting language = "c"> 
                <![CDATA[] 
            #include <stdio.h>
            #include <unistd.h>

            int main()
            {
                while(1)
                {
                    usleep(1000);
                }
            }
]]>
        </programlisting>>
        
        <para>
            Ez a program a while ciklusban a usleep(1000) utasítást végzi el. A usleep(seconds_t usec)
            az unistd.h fájlban definiált függvény. Adott usec mennyiségû mikroszekundumig megszakítja 
            a program mûködését.
        </para>      
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot Ã­rni, amely bÃ¡rmely mÃ¡s programrÃ³l eldÃ¶nti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldáás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszõeges programról el tudja dönteni, hogy van-e benne végtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az elõzõ <filename>v.c</filename> ilyen pszeudokódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épülõ Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog mûködni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változÃ³ értékét, bármifÃ©le logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            MegoldÃ¡s videÃ³: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            MegoldÃ¡s forrÃ¡sa:  
        </para>
        <programlisting language="c" >
        <![CDATA[
        #include <stdio.h>

        int main()
        {
            int a = 10;
            int b = 4;
            printf("a = %d\n", a);
            printf("b = %d\n", b);

            a = a - b;
            b = a + b;
            a = b - a;

            printf("a = %d\n", a);
            printf("b = %d\n", b);
        }
        ]]>
        </programlisting>
        <para>
            A fenti C program kiírja két változó értékét, felcseréli õket, majd kiírja a változók
            új értékeit. Az int a = 10 és int b = 4 megadják a és b értékeit. A printf() függvény
            kiírja a paraméteréül kapott stringet. Például a fent látható printf("a = %d\n", a)
            azt fogja kiírni hogy a = 10, majd egy új sort kezd. Ebbõl "a = %d\n" a string rész, amiben a
            %d egy format specifier. Feladata, hogy megmondja, a %d helyére
            egy decimális egész szám (itt: a) fog kerülni, amit a string rész utáni vesszõvel elválasztott 
            helyre kell írni. Ugyanitt a \n egy escape sequence, ami azt mondja a 
            printf függvénynek, hogy a \n helyére egy új sort írjon.
        </para>
        <para>
            Ezek után megkezdõdik a változók felcserélése a fenti mûveletek segítségével. Miután az kész,
            a program ismét kiírja a változók immár új felcserélt értékeit.
        </para>>
    </section>                     

    <section>
        <title>LabdapattogÃ¡s</title>
        <para>
            Elõször if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            használata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            MegoldÃ¡s videÃ³: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Labdapattogtatás if nélkül: 
        </para>
        
        <programlisting language = "C">
        <![CDATA[
        #include <stdio.h>
        #include <math.h>

        int write_x(x,y)
        {
            int xi,yi;

            for(xi=0;xi<x;xi++)
            {
                printf("\n");
            }

            for(yi=0;yi<y;yi++)
            {
                printf(" ");
            }
            printf("X\n");
            return 0;
        }

        int main()
        {

            int width = 90;
            int height = 25;
            long int x=0,y=0;

            while(1)
            {
                system("cls");
                write_x(abs(height - (x++ % (height * 2 ))), abs(width - (y++ % (width*2))));
                usleep(10);
            }

            return 0;
        }
        ]]>
        </programlisting>
        <para>
            A program Windows alatt egy adott 'pályán' pattogtat egy x-el jelölt 'labdát' a konzolon.
            Két függvénybõl áll, a már megszokott int main() és egy 
            int write_x(x,y) függvénybõl. A main függvényben meg van adva a pálya hossza, magassága
            és a labda koordinátái, amelyek alapesetben nullával egyenlõek. Ezek után a program egy 
            végtelen ciklusban elõször törli a képernyõt a system("cls") függvénnyel, majd meghívja a write_x() függvényt két abszolút értékre.
            Egy szám abszolút értékét az abs() függvénnyel számoljuk ki, ami a math.h fájlban van meghatározva.
            Ha a write_x() lefutott, akkor egy ideig megszûnik a munkavégzés és elõrõl kezdõdnek a ciklusban definiált lépések.
        </para>
        <para>
            Az int write_x(x,y) itt egy a felhasználó által megadott függvény. Az elõtte lévõ int szó azt jelenti, hogy
            a függvény egy integer, azaz egész szám típusú értéket fog visszaadni, amit a return 0 paranccsal teszünk meg 
           (return 0 azt jelenti, hogy a program probléma nélkül lefutott. Ha nem nullát ad vissza, akkor futás közben hiba történt.).
            A zárójelek közötti x és y számok a függvény paraméterei, tehát ezekkel fog dolgozni. A számokat függvényhívásnál
            kell megadni. A függvényen belül két for ciklus található. Az elsõ feladata, hogy a labda függõleges helyzetének
            megfelelõ új sort írjon ki, a másodiké pedig, hogy úgyanúgy a labda vízszintes pozíciójának megfelelõ szóközt írasson ki.
            Ha ez megtörtént, akkor a labda jelenlegi koordinájáihoz érkezett a kurzor. A for ciklusok befejezõdnek és printf()-el
            kiíratunk egy X-et.
        </para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnÃ©zi, hogy hÃ¡ny bites a szÃ³ a gÃ©peden, azaz mekkora az <type>int</type> mÃ©rete.
            HasznÃ¡ld ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjÃ¡ban! 
        </para>
        <para>
            MegoldÃ¡s videÃ³: <link xlink:href=""></link>
        </para>
        <para>
            MegoldÃ¡s forrÃ¡sa: <link xlink:href=""></link>
        </para>
        <para>
            TanulsÃ¡gok, tapasztalatok, magyarÃ¡zat... 
        </para>
    </section>                     

    <section>
        <title>HellÃ³, Google!</title>
        <para>
            Ãrj olyan C programot, amely egy 4 honlapbÃ³l Ã¡llÃ³ hÃ¡lÃ³zatra kiszÃ¡molja a nÃ©gy lap Page-Rank 
            Ã©rtÃ©kÃ©t!
        </para>
        <para>
            MegoldÃ¡s videÃ³: <link xlink:href=""></link>
        </para>
        <para>
            MegoldÃ¡s forrÃ¡sa: <link xlink:href=""></link>
        </para>
        <para>
            TanulsÃ¡gok, tapasztalatok, magyarÃ¡zat...
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 Ã©ves a Brun tÃ©tel</title>
        <para>
            Ãrj R szimulÃ¡ciÃ³t a Brun tÃ©tel demonstrÃ¡lÃ¡sÃ¡ra!
        </para>
        <para>
            MegoldÃ¡s videÃ³: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            MegoldÃ¡s forrÃ¡sa: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall problÃ©ma</title>
        <para>
            Ãrj R szimulÃ¡ciÃ³t a Monty Hall problÃ©mÃ¡ra!
        </para>
        <para>
            MegoldÃ¡s videÃ³: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            MegoldÃ¡s forrÃ¡sa: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            TanulsÃ¡gok, tapasztalatok, magyarÃ¡zat...
        </para>
    </section>

</chapter>                
