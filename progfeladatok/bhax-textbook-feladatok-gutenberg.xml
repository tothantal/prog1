<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            The C Programming Language, Brian W. Kernighan, Dennis M. Ritchie
	</para>
	
	<para>            
            1.1 Indulás.
        </para>
	<para>    
            A könyv írói szerint minden program elsajátítása a "Helló Világ!" program megírásával történik. 
            Ez C nyelven így néz ki:
         </para>
            <programlisting language = "c">

            <![CDATA[
            
include <stdio.h>

int main()
{
    printf("Hello World!"\n);
}
            
            ]]>
             </programlisting>
        <para>
            Ezt a forráskódot programnev.c néven kell elmenteni, futtatása operációs rendszertől függ.
            Lefordítása a "gcc programnev.c -nev" paranccsal történik, futtatása
            Linuxon "./nev" , Windows alatt "nev" a terminálból. A program eredménye a következőképpen fog kinézni:
            
            Hello World!
        </para>
        <para>
            Egy C program függvényekből (function) és változókból (variable) áll. 
            Egy függvény pedig állításokból (statement). Az állítások megmondják, hogy mit kell csinálni, a változók pedig
            a számításokhoz szükkséges értékeket tárolják.
            
            A munkánkat különböző könyvtárak segíthetik, amelyeket inkludálni kell. Ezt itt az első sor teszi.
            A legelső sor azt mondja a compilernek, hogy az stdio.h (standard input/output) fájl tartalmát
            másolja át a mi programfájlunkba.
            
        </para>
        <para>
            Az argumentumok azok az értékek, amelyeket függvényhíváskor adunk meg. Például a "printf("Helló Világ!\n")"
            esetén az printf() függvény argumentuma a "Helló Világ!\n" karakterlánc. Az argumentumokat mindig egy zárójelbe tesszük.
        </para>

	<para>
		1.2 Változók és aritmetikai kifejezések
	</para>
	<para>
		A következő program két oszlopban kiírja nullától háromszázig huszassával haladva
		a hőmérsékletet fahrenheit fokban mérve, és mellé celsiusban a C = (5/9)(F-32)
		képletet használva, ahol a C a celsius, F a fahrenheitban mért hőmérséklet.
	</para>
	<programlisting language = "c">
	<![CDATA[

	#include <stdio.h>

	/* fahrenheit celsius tabla kiíratasa
	fahr = 0, 20, ..., 300-ra */
	main()
	{
		int fahr, celsius;
		int lower, upper, step;

		lower = 0;	/* minimum homerseklet */
		upper = 300;	/* maximum homerseklet */
		step = 20;	/* lepesek nagysaga */

		/* 20-al noveljuk fahr erteket a maximum elereseig */
		fahr = lower;
		while (fahr <= upper) {
			celsius = 5 * (fahr - 32) / 9;
			printf("%d\t%d\n", fahr, celsius);
			fahr = fahr + step;
		}
	}

	]]>	
	</programlisting>
        <para>
		A változókat, használatuk előtt, mindig deklarálni kell a "típus név" formában.
Ezeket deklarációknak hívjuk. A C nyelvben több különböző változótípust ismerünk,
mint az int (integer - valósszám), char (character - karakter), float (floating point - lebegőpontos szám). A változók méretét tekintve is beszélhetünk mutatókról (pointer), tömbökről (array), uniókról (union), vagy struktúrákról (structure)
	</para>
	<para>
		A program azzal kezdődik, hogy elvégezzük a szükséges deklarációkat, illetve értékeket adunk a step, lower és upper értékeknek. Ezután következik egy while loop, miszerint amíg a fahr kisebb vagy egyenlő az upper számnál, addig számolja ki a fahrhoz tartozó celsius értéket és írassa ki. Végül növeljök a fahr értékét steppel.
	</para>
	<para>
		A while loopon belül láthatjuk, hogy a printf() függvényt használhatjuk az output formázására is. A %d decimális egész szám helyét jelöli, melyeket a kiírandó karakterlánc után adunk meg. Azt, hogy milyen értéket akarunk kiíratni a % jel utáni betűk és számok kombinációjával tudjuk meghatározni. Például %6d (minimum 6 karakter széles decimális integer),
%6.2f (minimum 6 karakter széles, tizedes vessző után két számjeggyel rendelkező lebegőpontos szám). Ugyanitt láthatunk példát escape sequence-re is (/n és /t). Az escape sequence-ek olyan / után írt karakterek, amelyeknek speciális funkcióik vannak. Például a /n új sort ír, a /t pedig egy tabulátort. 
	</para>
	<para>
		1.3 A for állítás
	</para>
	<para>
		Ebben a részben a következő kódrészletet láthatjuk:
	</para>
	<programlisting language = "c">
	<![CDATA[

	#include <stdio.h>

	main()
	{
		int fahr;

		for(fahr = 0; fahr <= 300; fahr = fahr + 20)
			printf("%3d %6.1f\n", fahr, (5.0/9.0*(fahr - 32)));
	}

	]]>
	</programlisting>
	<para>
		Ez a program ugyanazt csinálja, mint az előző, csak rövidebben van leírva. A legnagyobb változás a legtöbb változó elhagyása, csak a fahr marad meg. A másik nagyobb változás a for ciklus használata a while helyett, illetve a celsius értéket itt a printf() függvényen belül számoltatjuk ki.
	</para>
	<para>
		A <programlisting> <![CDATA[for (int mettol; mettol < meddig; lepes);]]> </programlisting> for ciklus mettol értéktől meddig értékig lepes lépésszámmal haladva elvégez valamilyen a ciklus belsejében lévő műveletet, vagy azok halmazát.
	</para>
	<para>
		1.4 Szimbolikus konstansok
	</para>
	<para>
		A konstansok olyan változók, amelyeknek az értékeit nem tervezzük megváltoztatni. Konstansokat a C nyelvben a következőképpen lehet definiálni:<programlisting language = "c"><![CDATA[#define NEV ertek]]></programlisting> Ahol a NEV a konstans neve, hagyományosan nagybetűkkel írva a könnyű megkülönböztetés érdekében, ertek pedig a konstans értéke.
	</para>
	<para>
		1.5 Karakter input és output
	</para>
	<para>
		A C programunk a szöveget karakterláncként kezeli, legegyszerűbb függvények, amelyek a szövegekkel dolgoznak a getchar() és a putchar(). Híváskor a getchar() beolvassa a kapott szöveget és visszaadja azt értékként, tehát a <programlisting language = "c"><![CDATA[c = getchar();]]></programlisting> beolvassa a kapott input szöveget és azt az értéket adja a c változónak.
	</para>
	<para>
		A getchar() párja a putchar( string ), amely kiírja egy adott string változó értékét, 
	</para>
	<para>
		A következő egyszerű program kiírja a beolvasott értéket a konzolra:
	</para>
	<programlisting language = "c">
	<![CDATA[
	#include <stdio.h>

	main()
	{
		int c;
		
		c = getchar();
		while( c != EOF )
		{
			putchar(c);
			c = getchar();
		}
	}
	]]>
	</programlisting>
	<para>
		A program úgy működik, hogy beolvassa az input értékeket és amíg az nem egyenlő az EOF értékkel (end of file, az az érték, ami azt jelzi, hogy nincs több input)
	</para>
	<para>
		Ugyanígy megszámoltathatjuk a beírt sorokat, ha a while ciklusba rekunk egy if fügvényt, ahol megnézzük, hogyha a beírt karakter egy új sor ( /n ), akkor egy nl = 0 változó értékét megnöveljük egyel, majd a program végén printf() -fel kiíratjuk azt.
	</para>
	<para>
		1.6 Tömbök
	</para>
	<para>
		Tömböket (array) a következőképpen adhatunk meg: int digits[10], ami például 10 egész szám típusú értéket tartalmazó digits nevű tömböt ad meg. A tömbök számozása nullától kezdődik, tehát hivatkozni az n-edik elemre digits[n-1] -ként kell. Ez fontos a for ciklusokkal való tömbök körbejárásánál, feltöltésénél, ahol ezért a számozást int i = 0 -tól kell kezdeni.	
	</para>
	<para>
		A függvényeket (function) általában a main után szoktuk definiálni a következőképpen:
	</para>
	<programlisting language = "c">
	<![CDATA[
	vszt_ert fgv_nev ( parameterek )
	{
		deklaraciok;
		utasitasok;
	}	
	]]>
	</programlisting>
	<para>
		Minden függvénymegadást a visszatérési értékkel (return value) kell kezdeni, ami a függvény által visszaadott érték típusa, majd ezután jön a függvény neve és utána () jelek között a paraméterei, azaz azok az értékek, amelyekkel a függvényünk dolgozni fog. Ezután jön a függvény teste, amelyekbe azokat az értékeket kell írnunk, amelyekkel dolgozni fog a függvényünk, illetve az utasításokat, amelyeket el fogja végezni. Ha a visszatérési értékünk nem nulla, azaz nem semmit ad vissza (void), akkor a return utasítással adhatjuk meg, hogy mit is adjon vissza a függvényünk.
	</para>
	<para>
		Bevett szokás még a prototipizálás, amely lényege, hogy még a main függvény előtt deklaráljuk, hogy milyen függvényeket fogunk használni. Tesszük ezt a függvény visszatérési értékének, nevének és paramétereinek a megadásával. Majd a main után definiáljuk, hogy mit is értünk a deklarált függvények alatt.
	</para>
	<para>
		A függvények azért hasznosak, mert csak egyszer kell őket megírni, ha az megvan, akkor a compiler beilleszti a kódjukat a megfelelő helyre. Tehát oda, ahol meghívjuk őket.
	</para>
	<para>
		1.8 Argumentumok, érték szerinti hívás
	</para>
	<para>
		C-ben minden függvény érték szerint hívja meg alapesetben az értékeket, azaz, nem az eredeti értékeket módosítják, hanem azoknak csak egy másolatát. Ennek az ellentetje, a referencia szerinti hívás, ahol a függvény a paramétereket módosítja, nem csak azok segítségével adja meg a visszatérési értéket. 
	</para>
	<para>
		1.9 Karaktertömbök
	</para>
	<para>
		C-ben a leggyakorib tömb a karaktertömb, azaz a karakterlánc, ami nevéhez hűen karakterek egy tömbje. Vegyük például a "hello\n" karakterláncot, ami áll lényegében a hello szóból és egy új sort jelképező \n jelből. A karaktertömbben, amiben ez a string el van tárolva, minden karakternek megvan a maga értéke, és minden karakter egy helyet foglal el (itt a "\n" egy karakternek minősül) plusz egy /0 karakter jelzi az adott karakterlánc végét. A %c és a %s formátum specifikációk egyenként egy karaktert és egy karakterláncot jelképeznek. 
	</para>
	<para>
		1.10 Scope
	</para>
	<para>
		Hatókör (scope) szerint megkülönböztetünk lokális és globális értékeket. A lokális értékek csak abban a fügvényblokkban érhetők el, ahol azokat deklaráltuk, de a globális értékek mindenhol. A globális értékeket a main függvényen kívül szokták deklarálni. Fontos, hogyha egy blokkon belül definiálunk egy lokális változót, amelynek a neve megegyezik egy globális változóéval, akkor az adott blokkon belül a lokális változó felülírja a globálist. Explicit módon deklarálhatunk globális változót az extern kulcsszó használatával. Ha egy külső változót szeretnék használni egy függvénnyel, akkor annak a változónak a nevét tudatnuk kell a függvénnyel, ezt az extern kulcsszóval tehetjük meg.
	</para>
	<para>
		2.1 Változók nevei
	</para>
	<para>
		A változók névadásainak vannak bizonyos szabályai. Minden változónév betűkből és számokból áll. Az első karakternek betűnek kell lennie. Az aláhúzásjel ( _ ) itt betűnek számít, de nem ajánlott velük változónevet kezdeni, mert a könyvtárakban sok folyamat azzal kezdődik.
	</para>
	<para>
		A C nyelvben vannak bizonyos kulcsszavak ( például: if, else, continue, int), amelyek nem lehetnek változónevek
	</para>
	<para>
		Jó ha olyan változóneveket választunk, amiknek közük van a feladatukhoz és nem túl hosszúak.
	</para>
	<para>
		2.2 Típusok és méretek
	</para>
	<para>
		A következő alaptípusok léteznek C-ben:
	char ( egy karakter tárolására alkalmas bájt. ), int (integer, egész szám), float (lebegőpontos szám), double (lebegőpontos szám, de nagyobb méretű, mint a float)
	</para>
	<para>
		Ezeken kívül még használhatóak a short és long kifejezések egész számokra, amelyek egyenként 16 és 32 bit méretűek. Megadásuk nem kötelező.
	</para>
	<para>
		A signed és az unsigned a char és int típusokkal használható, unsigned típusok mindig vagy 0 vagy pozitív értéket vesznek fel, signed értékek ezzel szemben lehetnek negatív számok is, a maximálisan felvehető pozitív értékük a felére minusz egyre csökken, tehár mivel a char 255 bitet vehet fel unsigned értékként, a maximális pozitív értéke signed értékként 127 bit. Minimum értéke -127.
	</para>
	<para>
		2.3 Konstansok
	</para>
	<para>
		A long és unsigned kulcsszavakon kívül egyenként felhasználhatjuk az L és U betűket is. Azaz az 1234 egy integer szám, az 123456789L egy long integer. A kettőt kombinálhatjuk UL-ként.
	</para>
	<para>
		Értéket megadhatunk nyolcas és hexadecimális számrendszerben is. Példaként a 31 számot leírhatjuk úgy hogy 037 (37<subscript>8</subscript>), vagy 0x1f (1F<subscript>16</subscript>)
	</para>
	<para>
		Az escape sequence egy / jel és egsy betű kombinácoiója, ami egy speciális karaktert jelöl. Példaként a már látott '\n' egy új sort jelöl. Az összes C-beli escape sequence:
	</para>
	<programlisting>
	<![CDATA[
		\a	\\ alert jel, sipolas
		\b	\\ backspace
		\f	\\ formfeed, lapdobas
		\n	\\ uj sor
		\r	\\ kocsi vissza
		\t	\\ horizontalis tab
		\v	\\ vertikalis tab
		\\	\\ \
		\?	\\ ? 
		\'	\\ '
		\"	\\ "
		\ooo	\\ oktalis szam
		\xhh	\\ hexadecimalis szam
	]]>
	</programlisting>
	<para>
		A konstans kifejezés egy olyan kifejezés, amely csak konstansokat tartalmaz. Például <programlisting><![CDATA[ #define MAXLINE 1000]]></programlisting> Egy MAXLINE nevű 1000 értékkel rendelkező konstanst definiál. A string konstans egy "" jelek közötti karakterlánc. Fontos tudni, hogy a stringet csak a "" jelek határozzák meg, tehát a "ab" "cd" egymás mellet egyenlő lesz "abcd"-vel, mindegy mennyi szóköz van közöttük.
	</para>
	<para>
		Egy másik fajta konstans az enumerációs konstans (enumeration constant), amire egy példa:
<programlisting><![CDATA[ enum boolean { NO, YES }]]></programlisting> Ami egy boolean nevű enum konstanst definiál. Az első értékhez ( itt: NO ) a 0 tartozik, a másodikhoz pedig az 1 és így tovább további elemek esetén.
	</para>
	<para>
		2.4 Deklarációk
	</para>
	<para>
		Minden változót deklarálni kell használat előtt. Egy tipikus deklaráció:
	<programlisting>
	<![CDATA[
	char c, d;
	]]>
	</programlisting>
	Ami egy c és egy d nevű char típusú változók deklarálása. A változókat lehet külön-külön és egyben is deklarálni. Természetesen a különbözü típusú változókat külön kell deklarálnunk. 
	</para>
	<para>
		Az inicializáció a deklaráció azon altípusa, amikor értéket is adunk a változónak. Például:
	<programlisting>
	<![CDATA[
	char c = "x", d = "y";
	]]>
	</programlisting>
	Itt megadjuk, hogy c legyen "x" betű és d legyen "y".
	</para>
	<para>
		deklarálhatunk a const kulcsszóval is, ha konstant kívánunk deklarálni. A folyamat ugyanaz, csak a típus elé oda kell írnunk, hogy const.
	</para>
	<para>
		2.5 Aritmetikai műveletek
	</para>
	<para>
		Binér (kétváltozós) aritmetikai operátorok a +,-,*,/,%. Ezek közül a % a modulus operátor. Feladata megmondani, hogy a % b esetén mennyi az a-nak b-vel való osztása eseténi maradék. Nem lehet float vagy double-lel alkalmazni. Precedencia szerint + és - azonos rangú, felettük a *, /, és % operátorok foglalnak helyet.
	</para>
	<para>
		2.6 Relációs és logikai operátorok
	</para>
	<para>
		Relációs operátorok a &lt;, &lt;=, &gt; és &gt;= . Egyenlőség operátorok az == és !=, ahol ! nemet jelent. Precedenciájuk az aritmetikai operátorok alatt van. 
	</para>
	<para>
		Logikai operátorok az &amp;&amp; (és) és || (vagy)
	</para>
	<para>
		2.7 Típus átváltások
	</para>
	<para>
		Különböző függvények léteznek típusok átváltásaira, például az
	<programlisting>
	<![CDATA[
	atoi(str)
	]]>
	</programlisting>
	Átváltja str-t egész számmá. Egyéb hasonló függvények a lower() és upper() amelyek egyenként csupa kis vagy nagybetűkké váltanak egy stringet.
	</para>
	<para>
		2.8 Inkrementálás és dekrememtálás
	</para>
	<para>
		Az inkrementálás annyit tesz, mint egyel megnövelni valami értékét (operátora: ++). Ellentetje a dekrementálás (--). Az inkrementálás a következőképpen jelölendő: n++, vagy ++n . A dekrementálás: n-- vagy --n . A különbség aközött, hogy az érték elé írjuk (prefix) vagy után (postfix), hogy a prefixes alakban n használatba kerülése előtt inkrementáljuk/dekrementáljuk az értékét, postfix alakban pedig használat után. 
	</para>
	<para>
		2.9 Bitműveletek
	</para>
	<para>
		A C nyelv 6 bitműveletet tartalmaz: &amp; (ÉS), | (inklúzív VAGY), ^ (exkluzív/kizáró VAGY), &lt;&lt; (left shift), &gt;&gt; (right shift) és ~ (komplementer) . A left és a right shift balra, vagy jobbra tolja az operátor bal oldalán lévő érték bitjeit az operátor jobb oldalán lévő számmal. (x &lt;&lt; 2; x bitjeit kettővel balra tolja.)
	</para>
	<para>
		2.10 Kifejezések és a megfeleltetés operátor
	</para>
	<para>
		Megfeleltetni az egyenlőség jellel kell. Ha op egy operátor, kif1 és kif2 kifejezések akkor 
	</para>
	<programlisting>

	<![CDATA[
		kif1 op= kif2
	]]>
	</programlisting>
	<para>
		Megegyezik a következővel:
	</para>
	<programlisting>
	<![CDATA[
		kif1 = kif1 op kif2
	]]>
	</programlisting>
	<para>
		2.11 Feltételes kifejezések
	</para>
	<programlisting>
	<![CDATA[
		z = (a > b) ? a : b;
	]]>
	</programlisting>
	<para>
		A fenti egy feltételes kifejezés. Jelentése: Ha a nagyobb b-nél, akkor z legyen a, egyébként legyen b. Ha a kérdőjel előtti kifejezés igazságértéke igaz, akkor a kettőpont előtti érték kerül felhasználásra, egyébként az azutáni.
	</para>
	<para>
		2.12 Precedencia
	</para>
	<para>
		Ez a rész a precedenciával, azaz a különböző operátorok végrehajtási sorrendjével. Elösször a zárójelek közötti kifejezéseket kell kiértékelni, aztán a kivonás, összeadás, a sizeof operátor, osztás, szorzás. Majd a relációs operátorok, aztán a bitműveletek, a logikai operátorok. A következő a feltételes kifejezés ?: operátor, majd végül a megfeleltető operátorok.
	</para>	
	<para>
		3.1 Utasítások és blokkok
	</para>
	<para>
		Egy kifejezés utasítás lesz, ha pontosvessző követi. A {} jelek utasításcsoportokat blokkokra osztanak. 
	</para>
	<para>
		3.2 If-else
	</para>
	<para>
		Az if-else utasítás a következőképpen néz ki:
	</para>
	<programlisting>
	<![CDATA[
		if (kifejezes)
			utasitasok
		else
			utasitasok
	]]>
	</programlisting>
	<para>
		Működése a következő: Az if() részben lévő kifejezés igazságértékét megnézve, ha az érték igaz, teljesíti ai if alatti utasításokat, majd átugorja az else alattiakat. Ha az érték hamis, akkor az if alattiakat ugorja át és az else alatti utasításokat végzi el. Egy soros utasítások esetén a () jelek nem szükségesek az if() és else() után. 
	</para>
	<para>
		3.3 Else-if
	</para>
	<programlisting>
	<![CDATA[
		if (kifejezes)
			utasitasok1
		else if (kifejezes)
			utasitasok2
		.......
		else if (kifejezes)
			utasitasokX
		else
			utasitasokx+1
	]]>
	</programlisting>
	<para>
		Az else-if utasytás hasonlóan működik az if-else-hez, a különbség az else utasítások számában rejlik, amiből annyit írhatunk, amennyire szükségünk van. A kiértékelés fentről lefelé halad, tehát ha az utolsó előtti kifejezés sem igaz, akkor az utolsó else-hez tartozó utasításokat fogja elvégezni a program.
	</para>
	<para>
		3.4 Switch
	</para>
	<programlisting>
	<![CDATA[
		switch (kifejezes)
			case konstans: utasitasok
			case konstans: utasitasok
			default: utasitasok
	]]>
	</programlisting>
	<para>
		A switch utasítás úgy működik, hogy a switch-beli kifejezés értéke lesz összevetve a case kulcsszavak utáni konstansokkal. Ha egyezés van, akkor az adott konstans utáni utasítások lesznek teljesítve. Ha nincs, akkor a default (alapértelmezett) utasításokra kerül a sor. Fontos, hogy ha egyezés van, akkor a többi case konstansaival való összevetés nem lesz átugorva, csak ha használjuk a break parancsot. 
	</para>
	<para>
		3.5 While és for
	</para>
	<programlisting>
	<![CDATA[
		while (kifejezes)
			utasitas
	]]>
	</programlisting>
	<para>
		Ez egy egyszerű while ciklus, ha a kifejezés igaz, az utasítások teljesülnek. Tipikusan az egyik utasítás a kifejezés módosításával van kapcsolatban, egyébként ha az igaz, akkor végtelen ciklusunk születik. 
	</para>
	<programlisting>
	<![CDATA[
		for(i = 0; i < n; i++)
			utasitasok
	]]>
	</programlisting>
	<para>
		Ez a for ciklus i = 0 értéket vizsgálja. Addig folytatódik a ciklus, amíg teljesül az első pontosvessző utáni kifejezés. A második pontosvessző utáni utasítás minden egyes ciklus után (az utasitasok végrehajtása után) végrehajtódik. 
	</para>
	<para>
		3.6 Do while
	</para>
	
	<programlisting>
	<![CDATA[
		do
			utasitasok
		while (kifejezes);
	]]>
	</programlisting>
	<para>
		A do-while ciklus hasonló a while ciklushoz, de azzal ellentétben itt mindenképp végrehajtódnak az utasítások egyszer. Majd aztán lesz megvizsgálva a releváns kifejezés igazságértéke. Fontos, hogy a while ciklussal ellentétben a do-while után kell a pontosvessző.
	</para>
	<para>
		3.7 Break és continue
	</para>
	<para>
		A break utasítás feladata a jelenlegi ciklusból való kilépés. A continue feladata a következő iteráció elkezdése.
	</para>
	<para>
		3.8 Goto és label
	</para>
	<para>
		A goto és a label utasítások használata szorosan összefügg. A goto leggyakoribb használata a beágyazott ciklusokból való kilépés. A label-t mindig egy kettőspont követi, a goto utasítást pedig a label neve, ahová szeretnénk "elugrani".
	</para>
        </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
	<para>
		A C++ nem objektumorientált tulajdonságai
	</para>
	<para>
		2.1 A C és a C++ nyelv
	</para>
	<para>
		2.1.1 Függvényparaméterek és visszatérési érték
	</para>
	<para>
		C-ben, ha egy függvénynek nem afunk paramétert, akkor az meghívható tetszőleges mennyiségű paraméterrel, C++-ban viszont ez azt jelenti, hogy a függvény nem kér paramétert, azaz visszatérési értéke void. C-ben az alapértelmezett visszatérési érték int, C++-ban ilyen nincs.
	</para>
	<para>
		2.1.2 A main függvény
	</para>
	<para>
		C-vel ellentétben a C++-ban a main függvény kaphat argc és argv parancssori argumentumokat, amik az argumentumok számát és magukat az argumentumokat jelentik sorban. 
	</para>
	<para>
		2.1.3 A bool típus
	</para>
	<para>
		A C++-ban a C-vel ellentétben létezik bool (boolean - logikai érték) típus. Értéke lehet true (1) vagy false (0). C-ben a logikai értéket int vagy enummal reprezentálhatjuk. 
	</para>
	<para>
		2.1.4 A C stílusú több-bájtos sztringek
	</para>
	<para>
		A több-bájtos, pl. Unicode karakterek reprezentálására a C-ben rendelkezésre áll a w_char típus, amihez inkludálni kell a stddef.h és stdlib.h vagy wchar.h fájlokat. A C++ nyelven a wchar_t egy beépített. 
	</para>
	<para>
		2.1.5 Változódeklaráció mint utasítás
	</para>
	<para>
		C++-ban minden olyan helyen állhat változódeklaráció, ahol utasítás állhat. Ott hozhatjuk létre a változókat, ahol valóban szükségünk van rájuk. Minden változó onnan használható, ahonnan deklaráljuk
	</para>
	<para>
		2.2 Függvénynevek túlterhelése
	</para>
	<para>
		C-ben minden függvényt a neve azonosít csak, C++-ban nemcsak a név, de a függvényekhez rendelt argumentumok száma és típusa is segít az azonosításban, aminek az az eredménye, hogy míg C-ben nem lehet, addig C++-ban lehet túlterhelni függvényt, azaz két különböző függvény rendelkezhet azonos névvel.
	</para>
	<para>
		2.3 Alapértelmezett függvényargumentumok
	</para>
	<para>
		A C++-ban lehetőség van a függvények argumentumainak alapértelmezett érték adására. Amikor így hívunk függvényeket, nem adunk meg argumentumokat. 
	</para>
	<para>
		2.4 Paraméteradás referenciatípussal
	</para>
	<para>
		C-ben csak érték szerinti paraméteradás történik. Tehát egy függvény csak akkor fog módosítani értéket, hogyha egy arra mutató mutatót adunk meg argumentumnak. Ezzel szemben a C++ kínál referencia szerinti paraméteradást is, amelyel már módosítja az értékeket az adott függvény.
	</para>
	<para>
		3. Objektumok és osztályok
	</para>
	<para>
		3.1 Objektumorientáltság alapelvei
	</para>
	<para>
		Az egyik alapelv amivel foglalkoznuk kell az az egységbezárás (encapsulation) alapelve, ahol egy bizonyos adatstruktúrát szeretnénk megjeleníteni a programunkban. Az egységbe záró adatstruktúra neve osztály vagy class. Az osztályok egyedi példányait objektumoknak nevezzük. 
	</para>
	<para>
		3.2 Egységbezárás C++-ban
	</para>
	<para>
		C-ben az egységbezárást a struct kulcsszóval tesszük, struktúra típusba zárunk. Ugyanazt megtehetjük C++-ban is, de ott már nem csak tagváltozói lehetnek egy struktúrának, hanem tagfüggvényei is. A tagváltozót gyakran attribútumnak, a tagfüggvényt metódusnak nevezzük.
	</para>
	<para>
		3.3 Adatrejtés
	</para>
	<para>
		Adatrejtésre szolgál a private kulcsszó, amivel olyan adatokat adhatunk meg, amelyeket nem szeretnénk semmiképpen sem módosítani.
	</para>
	<para>
		3.4 Konstruktorok és destruktorok
	</para>
	<para>
		A konstruktor lehetőséget kínál arra, hogy az objektumok létrejüttükkör inicializálják magukat. 
	</para>
	<para>
		A konstruktorral szemben a destruktor az objektumok által birtokolt esetleges erőforrások felszabadítsát végzi el. 
	</para>
	<para> 
		3.5 Dinamikus adattagot tartalmazó osztály
	</para>
	<para>
		Ide tartozik a dinamikus memóriakezelés, a dinamikus adattagok támogatása és a másoló konstruktor.
	</para>
	<para>
		3.6 Friend függvények
	</para>
	<para>
		Az egyes osztályok feljogosíthatnak globális függvényeket a védett tagjaikhoz való hozzáférésre. Ezt a friend kulcsszóval tehetjük meg. A konstruktor olyan speciális függvény, amelynek neve megegyezik az osztály nevével és a példányosításakor automatikusan meghívódik. 
	</para>
	<para>
		3.7 Tagváltozók inicializálása
	</para>
	<para>
		Objektumok állapotát lehet inicializálni konstruktorokban. Az értékadást és inicializálást a C++ nyelvben meg kell különböztetni. Inicializálás a változók létrehozásához kapcsolódik, értékadás a már meglévő változóknak való értékmódosítása, amit az egyenlőségjellel érhetünk el.
	</para>
	<para>
		3.8 Statikus tagok
	</para>
	<para>
		Osztályok esetében lehetőség van olyan speciális, úgynevezett statikus tagváltozók definiálására, melyek az adott osztályhoz és nem az osztály objektumaihoz tartoznak.
	</para>
	<para>
		3.9 Beágyazott definíciók
	</para>
	<para>
		A C++ nyelvben lehetőség van enumeráció-, osztály-, struktúra- és típusdefiníciók osztálydefiníción belüli megadására. Ezeket beágyazott definícióknak nevezzük.
	</para>
	<para>
		6. Operátorok és túlterhelésük
	</para>
	<para>
		6.1 Operátorok általában
	</para>
	<para>
		C-ben az operátorok az argumentumaikon végeznek műveleteket, adott eredményeket a visszatérési értékeik feldolgozásával használhatjuk. Az operátorok visszatérítési értékét speciális szabályrendszer rögzíti. A C++ a C-hez képest bevezet néhány új operátort, mint a hatókör-operátor (::) vagy pointer-tag operátorok (.* és ->). 
	</para>
	<para>
		6.2 Függvényszintaxis és túlterhelés
	</para>
	<para>
		Az operátorok speciális függvények, így a C++-ban túlterhelhetők. Ezt az operator kulcsszóval érhetjük el, előtte a visszatérési érték, majd a kulcsszó után maga az operátor jele és utána zárójelekben az operátor argumentumai.
	</para>
    </section>        
</chapter>                
